// lex.yy.cpp generated by reflex 1.1.4 from lex.flex

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 3 "lex.flex"

  #include <iostream>
  #include <sstream>
  #include <fstream>

std::wstringstream ss;



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL("(?m)((?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:د)(?:ي)(?:ن)(?:ا)(?:م)(?:ي)(?:ك)(?:ي))|((?:ب)(?:ا)(?:ر)(?:ة)_(?:ث)(?:ا)(?:ب)(?:ت)(?:ة))|((?:ط)(?:غ)(?:ى)_(?:ا)(?:ل)(?:ت)(?:ح)(?:و)(?:ي)(?:ل))|((?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:د)(?:ا)(?:ئ)(?:م))|((?:ل)(?:ا)_(?:ا)(?:س)(?:ت)(?:ث)(?:ن)(?:ا)(?:ء))|((?:ت)(?:أ)(?:ك)(?:ي)(?:د)_(?:ث)(?:ا)(?:ب)(?:ت))|((?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:ث)(?:ا)(?:ب)(?:ت))|((?:م)(?:ؤ)(?:ش)(?:ر)_(?:ص)(?:ف)(?:ر)(?:ي))|((?:أ)(?:و)_(?:ح)_(?:ح)(?:د)(?:ث))|((?:أ)(?:و)(?:ـ)(?:ح)_(?:ح)(?:د)(?:ث))|((?:ا)(?:و)_(?:ح)_(?:ح)(?:د)(?:ث))|((?:ا)(?:و)(?:ـ)(?:ح)_(?:ح)(?:د)(?:ث))|((?:أ)(?:ع)(?:ل)(?:ن)_(?:ن)(?:و)(?:ع))|((?:ا)(?:ذ)(?:ه)(?:ب)_(?:ا)(?:ل)(?:ى))|((?:خ)(?:ي)(?:ط)_(?:م)(?:ح)(?:ل)(?:ي))|((?:ر)(?:م)(?:ز)(?:١)(?:٦)_(?:ن))|((?:ر)(?:م)(?:ز)(?:١)(?:٦)(?:ـ)(?:ن))|((?:ر)(?:م)(?:ز)16_(?:ن))|((?:ر)(?:م)(?:ز)16(?:ـ)(?:ن))|((?:ر)(?:م)(?:ز)(?:٣)(?:٢)_(?:ن))|((?:ر)(?:م)(?:ز)(?:٣)(?:٢)(?:ـ)(?:ن))|((?:ر)(?:م)(?:ز)32_(?:ن))|((?:ر)(?:م)(?:ز)32(?:ـ)(?:ن))|((?:ن)(?:ف)(?:ي)_(?:ح)(?:د)(?:ث))|((?:ح)(?:د)(?:د)_(?:ن)(?:و)(?:ع))|((?:ع)(?:ر)(?:ف)_(?:ن)(?:و)(?:ع))|((?:ا)(?:س)(?:م)_(?:ن)(?:و)(?:ع))|((?:ا)(?:س)(?:ت)(?:ع)(?:م)(?:ا)(?:ل))|((?:ا)(?:ف)(?:ت)(?:ر)(?:ا)(?:ض)(?:ي))|((?:ر)(?:م)(?:ز)_(?:ع)_(?:ن))|((?:ر)(?:م)(?:ز)(?:ـ)(?:ع)(?:ـ)(?:ن))|((?:ح)(?:ا)(?:ذ)(?:ى)_(?:ك))|((?:أ)(?:و)_(?:ح)(?:د)(?:ث))|((?:ا)(?:و)_(?:ح)(?:د)(?:ث))|((?:و)_(?:ح)(?:د)(?:ث))|((?:ب)(?:ت)_(?:ا)(?:و))|((?:ب)(?:ت)_(?:أ)(?:و))|((?:ا)(?:ك)(?:س)(?:ر)(?:ي))|((?:أ)(?:ك)(?:س)(?:ر)(?:ي))|((?:م)(?:ب)(?:د)(?:ئ)(?:ي))|((?:أ)(?:ش)(?:ط)(?:ب)(?:ي))|((?:ت)(?:ع)(?:د)(?:ا)(?:د))|((?:خ)(?:ا)(?:ر)(?:ج)(?:ي))|((?:أ)(?:خ)(?:ي)(?:ر)(?:ة))|((?:م)(?:ت)(?:ح)(?:ر)(?:ك))|((?:ص)(?:د)(?:ي)(?:ق)(?:ة))|((?:م)(?:ت)(?:غ)(?:ي)(?:ر))|((?:ج)(?:د)(?:ي)(?:د)(?:ة))|((?:م)(?:ح)(?:م)(?:ي)(?:ة))|((?:ث)(?:ن)(?:ا)(?:ئ)(?:ي))|((?:ث)(?:ا)(?:ب)(?:ت)(?:ة))|((?:ت)(?:ب)(?:د)(?:ي)(?:ل))|((?:ح)(?:ا)(?:و)(?:ل)(?:ي))|((?:ا)(?:ت)(?:ح)(?:ا)(?:د))|((?:م)(?:ت)(?:ل)(?:ا)(?:ش))|((?:ح)(?:ي)(?:ن)(?:م)(?:ا))|((?:ع)(?:ن)(?:د)(?:م)(?:ا))|((?:ر)(?:ئ)(?:ي)(?:س)(?:ي))|((?:أ)(?:ل)(?:ت)(?:ق)(?:ط))|((?:م)(?:ح)(?:ا)(?:ذ))|((?:أ)(?:س)(?:ا)(?:س))|((?:ذ)(?:ا)(?:ت)(?:ي))|((?:ب)(?:ت)_(?:و))|((?:أ)(?:ك)(?:س)(?:ر))|((?:ا)(?:ك)(?:س)(?:ر))|((?:ح)(?:ا)(?:ل)(?:ة))|((?:م)(?:ت)(?:م)(?:م))|((?:د)(?:ا)(?:ئ)(?:م))|((?:أ)(?:و)(?:ـ)(?:ح))|((?:أ)(?:و)_(?:ح))|((?:ا)(?:و)(?:ـ)(?:ح))|((?:ا)(?:و)_(?:ح))|((?:أ)(?:ك)(?:م)(?:ل))|((?:ا)(?:ش)(?:ط)(?:ب))|((?:ا)(?:ف)(?:ع)(?:ل))|((?:م)(?:ح)(?:د)(?:د))|((?:أ)(?:خ)(?:ي)(?:ر))|((?:ص)(?:د)(?:ي)(?:ق))|((?:ص)(?:ح)(?:ي)(?:ح))|((?:ك)(?:ب)(?:ي)(?:ر))|((?:ن)(?:ط)(?:ا)(?:ق))|((?:ج)(?:د)(?:ي)(?:د))|((?:ص)(?:ف)(?:ر)(?:ي))|((?:ع)(?:ا)(?:م)(?:ل))|((?:ا)(?:س)(?:ب)(?:ق))|((?:م)(?:ح)(?:م)(?:ي))|((?:ع)(?:ل)(?:ن)(?:ي))|((?:ص)(?:غ)(?:ي)(?:ر))|((?:ث)(?:ا)(?:ب)(?:ت))|((?:ب)(?:ن)(?:ي)(?:ة))|((?:ق)(?:ا)(?:ل)(?:ب))|((?:أ)(?:ر)(?:م)(?:ي))|((?:ا)(?:ر)(?:م)(?:ي))|((?:ص)(?:و)(?:ا)(?:ب))|((?:ح)(?:ا)(?:و)(?:ل))|((?:م)(?:ط)(?:ل)(?:ق))|((?:غ)(?:ا)(?:ئ)(?:ب))|((?:ب)(?:و)(?:ل))|((?:ر)(?:م)(?:ز))|((?:ص)(?:ن)(?:ف))|((?:إ)(?:ل)(?:ا))|((?:ا)(?:ل)(?:ا))|((?:ض)(?:ع)(?:ف))|((?:خ)(?:ط)(?:أ))|((?:ا)(?:ذ)(?:ا))|((?:إ)(?:ذ)(?:ا))|((?:ن)(?:ف)(?:ي))|((?:س)(?:ر)(?:ي))|((?:ا)(?:ع)(?:د))|((?:أ)(?:ع)(?:د))|((?:ح)(?:ج)(?:م))|((?:ه)(?:ذ)(?:ا))|((?:ه)(?:ذ)(?:ه))|((?:ل)(?:م)(?:ا))|((?:أ)(?:و))|((?:ا)(?:و))|((?:ض)(?:م))|((?:و))|((?:ل))|((?:\\x5b|\\x5d|\\x7b|\\x7d))|((?:٠))|((?:١))|((?:٢))|((?:٣))|((?:٤))|((?:٥))|((?:٦))|((?:٧))|((?:٨))|((?:٩))|((?:؛))|((?:،))|((?:\\Q.\\E)+)|((?:\\Q,\\E)+)|((?:_|[\\xd8-\\xdb][\\x80-\\xbf])+)|((?:(?:[0-9]|[A-Z]|[a-z]))+)|((?:[\\x09-\\x0d]|\\x20|\\x5b))|((?:[!-#]|[%-,]|[./]|[:-_]|\\x7c|\\x7e))|((?:.[\\x80-\\xbf]*))");
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 18: (?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:د)(?:ي)(?:ن)(?:ا)(?:م)(?:ي)(?:ك)(?:ي)
#line 18 "lex.flex"
{ss << L"dynamic_cast";}

            break;
          case 2: // rule at line 20: (?:ب)(?:ا)(?:ر)(?:ة)_(?:ث)(?:ا)(?:ب)(?:ت)(?:ة)
#line 20 "lex.flex"
{ss << L"constexpr";}
            break;
          case 3: // rule at line 21: (?:ط)(?:غ)(?:ى)_(?:ا)(?:ل)(?:ت)(?:ح)(?:و)(?:ي)(?:ل)
#line 21 "lex.flex"
{ss << L"reinterpret_cast";}

            break;
          case 4: // rule at line 23: (?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:د)(?:ا)(?:ئ)(?:م)
#line 23 "lex.flex"
{ss << L"const_cast";}
            break;
          case 5: // rule at line 24: (?:ل)(?:ا)_(?:ا)(?:س)(?:ت)(?:ث)(?:ن)(?:ا)(?:ء)
#line 24 "lex.flex"
{ss << L"noexcept";}
            break;
          case 6: // rule at line 25: (?:ت)(?:أ)(?:ك)(?:ي)(?:د)_(?:ث)(?:ا)(?:ب)(?:ت)
#line 25 "lex.flex"
{ss << L"static_assert";}
            break;
          case 7: // rule at line 26: (?:ت)(?:ح)(?:و)(?:ي)(?:ل)_(?:ث)(?:ا)(?:ب)(?:ت)
#line 26 "lex.flex"
{ss << L"static_cast";}

            break;
          case 8: // rule at line 28: (?:م)(?:ؤ)(?:ش)(?:ر)_(?:ص)(?:ف)(?:ر)(?:ي)
#line 28 "lex.flex"
{ss << L"nullptr";}

            break;
          case 9: // rule at line 30: (?:أ)(?:و)_(?:ح)_(?:ح)(?:د)(?:ث)
          case 10: // rule at line 31: (?:أ)(?:و)(?:ـ)(?:ح)_(?:ح)(?:د)(?:ث)
          case 11: // rule at line 32: (?:ا)(?:و)_(?:ح)_(?:ح)(?:د)(?:ث)
          case 12: // rule at line 33: (?:ا)(?:و)(?:ـ)(?:ح)_(?:ح)(?:د)(?:ث)
#line 33 "lex.flex"
{ss << L"xor_eq";}
            break;
          case 13: // rule at line 34: (?:أ)(?:ع)(?:ل)(?:ن)_(?:ن)(?:و)(?:ع)
#line 34 "lex.flex"
{ss << L"decltype";}
            break;
          case 14: // rule at line 35: (?:ا)(?:ذ)(?:ه)(?:ب)_(?:ا)(?:ل)(?:ى)
#line 35 "lex.flex"
{ss << L"goto";}
            break;
          case 15: // rule at line 36: (?:خ)(?:ي)(?:ط)_(?:م)(?:ح)(?:ل)(?:ي)
#line 36 "lex.flex"
{ss << L"thread_local";}


            break;
          case 16: // rule at line 39: (?:ر)(?:م)(?:ز)(?:١)(?:٦)_(?:ن)
          case 17: // rule at line 40: (?:ر)(?:م)(?:ز)(?:١)(?:٦)(?:ـ)(?:ن)
          case 18: // rule at line 41: (?:ر)(?:م)(?:ز)16_(?:ن)
          case 19: // rule at line 42: (?:ر)(?:م)(?:ز)16(?:ـ)(?:ن)
#line 42 "lex.flex"
{ss << L"char16_t";}
            break;
          case 20: // rule at line 43: (?:ر)(?:م)(?:ز)(?:٣)(?:٢)_(?:ن)
          case 21: // rule at line 44: (?:ر)(?:م)(?:ز)(?:٣)(?:٢)(?:ـ)(?:ن)
          case 22: // rule at line 45: (?:ر)(?:م)(?:ز)32_(?:ن)
          case 23: // rule at line 46: (?:ر)(?:م)(?:ز)32(?:ـ)(?:ن)
#line 46 "lex.flex"
{ss << L"char32_t";}
            break;
          case 24: // rule at line 47: (?:ن)(?:ف)(?:ي)_(?:ح)(?:د)(?:ث)
#line 47 "lex.flex"
{ss << L"not_eq";}
            break;
          case 25: // rule at line 48: (?:ح)(?:د)(?:د)_(?:ن)(?:و)(?:ع)
#line 48 "lex.flex"
{ss << L"typedef";}
            break;
          case 26: // rule at line 49: (?:ع)(?:ر)(?:ف)_(?:ن)(?:و)(?:ع)
#line 49 "lex.flex"
{ss << L"typeid";}
            break;
          case 27: // rule at line 50: (?:ا)(?:س)(?:م)_(?:ن)(?:و)(?:ع)
#line 50 "lex.flex"
{ss << L"typename";}
            break;
          case 28: // rule at line 51: (?:ا)(?:س)(?:ت)(?:ع)(?:م)(?:ا)(?:ل)
#line 51 "lex.flex"
{ss << L"using";}
            break;
          case 29: // rule at line 52: (?:ا)(?:ف)(?:ت)(?:ر)(?:ا)(?:ض)(?:ي)
#line 52 "lex.flex"
{ss << L"virtual";}
            break;
          case 30: // rule at line 53: (?:ر)(?:م)(?:ز)_(?:ع)_(?:ن)
          case 31: // rule at line 54: (?:ر)(?:م)(?:ز)(?:ـ)(?:ع)(?:ـ)(?:ن)
#line 54 "lex.flex"
{ss << L"wchar_t";}

            break;
          case 32: // rule at line 56: (?:ح)(?:ا)(?:ذ)(?:ى)_(?:ك)
#line 56 "lex.flex"
{ss << L"alignas";}
            break;
          case 33: // rule at line 57: (?:أ)(?:و)_(?:ح)(?:د)(?:ث)
          case 34: // rule at line 58: (?:ا)(?:و)_(?:ح)(?:د)(?:ث)
#line 58 "lex.flex"
{ss << L"or_eq";}

            break;
          case 35: // rule at line 60: (?:و)_(?:ح)(?:د)(?:ث)
#line 60 "lex.flex"
{ss << L"and_eq";}
            break;
          case 36: // rule at line 61: (?:ب)(?:ت)_(?:ا)(?:و)
          case 37: // rule at line 62: (?:ب)(?:ت)_(?:أ)(?:و)
#line 62 "lex.flex"
{ss << L"bitor";}
            break;
          case 38: // rule at line 63: (?:ا)(?:ك)(?:س)(?:ر)(?:ي)
          case 39: // rule at line 64: (?:أ)(?:ك)(?:س)(?:ر)(?:ي)
#line 64 "lex.flex"
{ss << L"break";}
            break;
          case 40: // rule at line 65: (?:م)(?:ب)(?:د)(?:ئ)(?:ي)
#line 65 "lex.flex"
{ss << L"default";}
            break;
          case 41: // rule at line 66: (?:أ)(?:ش)(?:ط)(?:ب)(?:ي)
#line 66 "lex.flex"
{ss << L"delete";}
            break;
          case 42: // rule at line 67: (?:ت)(?:ع)(?:د)(?:ا)(?:د)
#line 67 "lex.flex"
{ss << L"enum";}
            break;
          case 43: // rule at line 68: (?:خ)(?:ا)(?:ر)(?:ج)(?:ي)
#line 68 "lex.flex"
{ss << L"extern";}
            break;
          case 44: // rule at line 69: (?:أ)(?:خ)(?:ي)(?:ر)(?:ة)
#line 69 "lex.flex"
{ss << L"final";}
            break;
          case 45: // rule at line 70: (?:م)(?:ت)(?:ح)(?:ر)(?:ك)
#line 70 "lex.flex"
{ss << L"float";}
            break;
          case 46: // rule at line 71: (?:ص)(?:د)(?:ي)(?:ق)(?:ة)
#line 71 "lex.flex"
{ss << L"friend";}
            break;
          case 47: // rule at line 72: (?:م)(?:ت)(?:غ)(?:ي)(?:ر)
#line 72 "lex.flex"
{ss << L"mutable";}
            break;
          case 48: // rule at line 73: (?:ج)(?:د)(?:ي)(?:د)(?:ة)
#line 73 "lex.flex"
{ss << L"new";}
            break;
          case 49: // rule at line 74: (?:م)(?:ح)(?:م)(?:ي)(?:ة)
#line 74 "lex.flex"
{ss << L"protected";}
            break;
          case 50: // rule at line 75: (?:ث)(?:ن)(?:ا)(?:ئ)(?:ي)
#line 75 "lex.flex"
{ss << L"signed";}
            break;
          case 51: // rule at line 76: (?:ث)(?:ا)(?:ب)(?:ت)(?:ة)
#line 76 "lex.flex"
{ss << L"static";}
            break;
          case 52: // rule at line 77: (?:ت)(?:ب)(?:د)(?:ي)(?:ل)
#line 77 "lex.flex"
{ss << L"switch";}
            break;
          case 53: // rule at line 78: (?:ح)(?:ا)(?:و)(?:ل)(?:ي)
#line 78 "lex.flex"
{ss << L"try";}
            break;
          case 54: // rule at line 79: (?:ا)(?:ت)(?:ح)(?:ا)(?:د)
#line 79 "lex.flex"
{ss << L"union";}
            break;
          case 55: // rule at line 80: (?:م)(?:ت)(?:ل)(?:ا)(?:ش)
#line 80 "lex.flex"
{ss << L"volatile";}
            break;
          case 56: // rule at line 81: (?:ح)(?:ي)(?:ن)(?:م)(?:ا)
          case 57: // rule at line 82: (?:ع)(?:ن)(?:د)(?:م)(?:ا)
#line 82 "lex.flex"
{ss << L"while";}
            break;
          case 58: // rule at line 83: (?:ر)(?:ئ)(?:ي)(?:س)(?:ي)
#line 83 "lex.flex"
{ss << L"main";}
            break;
          case 59: // rule at line 84: (?:أ)(?:ل)(?:ت)(?:ق)(?:ط)
#line 84 "lex.flex"
{ss << L"catch";}


            break;
          case 60: // rule at line 87: (?:م)(?:ح)(?:ا)(?:ذ)
#line 87 "lex.flex"
{ss << L"alignof";}
            break;
          case 61: // rule at line 88: (?:أ)(?:س)(?:ا)(?:س)
#line 88 "lex.flex"
{ss << L"asm";}
            break;
          case 62: // rule at line 89: (?:ذ)(?:ا)(?:ت)(?:ي)
#line 89 "lex.flex"
{ss << L"auto";}
            break;
          case 63: // rule at line 90: (?:ب)(?:ت)_(?:و)
#line 90 "lex.flex"
{ss << L"bitand";}
            break;
          case 64: // rule at line 91: (?:أ)(?:ك)(?:س)(?:ر)
          case 65: // rule at line 92: (?:ا)(?:ك)(?:س)(?:ر)
#line 92 "lex.flex"
{ss << L"break";}
            break;
          case 66: // rule at line 93: (?:ح)(?:ا)(?:ل)(?:ة)
#line 93 "lex.flex"
{ss << L"case";}
            break;
          case 67: // rule at line 94: (?:م)(?:ت)(?:م)(?:م)
#line 94 "lex.flex"
{ss << L"compl";}
            break;
          case 68: // rule at line 95: (?:د)(?:ا)(?:ئ)(?:م)
#line 95 "lex.flex"
{ss << L"const";}
            break;
          case 69: // rule at line 96: (?:أ)(?:و)(?:ـ)(?:ح)
          case 70: // rule at line 97: (?:أ)(?:و)_(?:ح)
          case 71: // rule at line 98: (?:ا)(?:و)(?:ـ)(?:ح)
          case 72: // rule at line 99: (?:ا)(?:و)_(?:ح)
#line 99 "lex.flex"
{ss << L"xor";}
            break;
          case 73: // rule at line 100: (?:أ)(?:ك)(?:م)(?:ل)
#line 100 "lex.flex"
{ss << L"continue";}
            break;
          case 74: // rule at line 101: (?:ا)(?:ش)(?:ط)(?:ب)
#line 101 "lex.flex"
{ss << L"delete";}
            break;
          case 75: // rule at line 102: (?:ا)(?:ف)(?:ع)(?:ل)
#line 102 "lex.flex"
{ss << L"do";}
            break;
          case 76: // rule at line 103: (?:م)(?:ح)(?:د)(?:د)
#line 103 "lex.flex"
{ss << L"explicit";}
            break;
          case 77: // rule at line 104: (?:أ)(?:خ)(?:ي)(?:ر)
#line 104 "lex.flex"
{ss << L"final";}
            break;
          case 78: // rule at line 105: (?:ص)(?:د)(?:ي)(?:ق)
#line 105 "lex.flex"
{ss << L"friend";}
            break;
          case 79: // rule at line 106: (?:ص)(?:ح)(?:ي)(?:ح)
#line 106 "lex.flex"
{ss << L"int";}
            break;
          case 80: // rule at line 107: (?:ك)(?:ب)(?:ي)(?:ر)
#line 107 "lex.flex"
{ss << L"long";}
            break;
          case 81: // rule at line 108: (?:ن)(?:ط)(?:ا)(?:ق)
#line 108 "lex.flex"
{ss << L"namespace";}
            break;
          case 82: // rule at line 109: (?:ج)(?:د)(?:ي)(?:د)
#line 109 "lex.flex"
{ss << L"new";}
            break;
          case 83: // rule at line 110: (?:ص)(?:ف)(?:ر)(?:ي)
#line 110 "lex.flex"
{ss << L"NULL";}
            break;
          case 84: // rule at line 111: (?:ع)(?:ا)(?:م)(?:ل)
#line 111 "lex.flex"
{ss << L"operator";}
            break;
          case 85: // rule at line 112: (?:ا)(?:س)(?:ب)(?:ق)
#line 112 "lex.flex"
{ss << L"override";}
            break;
          case 86: // rule at line 113: (?:م)(?:ح)(?:م)(?:ي)
#line 113 "lex.flex"
{ss << L"protected";}
            break;
          case 87: // rule at line 114: (?:ع)(?:ل)(?:ن)(?:ي)
#line 114 "lex.flex"
{ss << L"public";}
            break;
          case 88: // rule at line 115: (?:ص)(?:غ)(?:ي)(?:ر)
#line 115 "lex.flex"
{ss << L"short";}
            break;
          case 89: // rule at line 116: (?:ث)(?:ا)(?:ب)(?:ت)
#line 116 "lex.flex"
{ss << L"static";}
            break;
          case 90: // rule at line 117: (?:ب)(?:ن)(?:ي)(?:ة)
#line 117 "lex.flex"
{ss << L"struct";}
            break;
          case 91: // rule at line 118: (?:ق)(?:ا)(?:ل)(?:ب)
#line 118 "lex.flex"
{ss << L"template";}
            break;
          case 92: // rule at line 119: (?:أ)(?:ر)(?:م)(?:ي)
          case 93: // rule at line 120: (?:ا)(?:ر)(?:م)(?:ي)
#line 120 "lex.flex"
{ss << L"throw";}
            break;
          case 94: // rule at line 121: (?:ص)(?:و)(?:ا)(?:ب)
#line 121 "lex.flex"
{ss << L"true";}
            break;
          case 95: // rule at line 122: (?:ح)(?:ا)(?:و)(?:ل)
#line 122 "lex.flex"
{ss << L"try";}
            break;
          case 96: // rule at line 123: (?:م)(?:ط)(?:ل)(?:ق)
#line 123 "lex.flex"
{ss << L"unsigned";}
            break;
          case 97: // rule at line 124: (?:غ)(?:ا)(?:ئ)(?:ب)
#line 124 "lex.flex"
{ss << L"void";}


            break;
          case 98: // rule at line 127: (?:ب)(?:و)(?:ل)
#line 127 "lex.flex"
{ss << L"bool";}
            break;
          case 99: // rule at line 128: (?:ر)(?:م)(?:ز)
#line 128 "lex.flex"
{ss << L"char";}
            break;
          case 100: // rule at line 129: (?:ص)(?:ن)(?:ف)
#line 129 "lex.flex"
{ss << L"class";}
            break;
          case 101: // rule at line 130: (?:إ)(?:ل)(?:ا)
          case 102: // rule at line 131: (?:ا)(?:ل)(?:ا)
#line 131 "lex.flex"
{ss << L"else";}
            break;
          case 103: // rule at line 132: (?:ض)(?:ع)(?:ف)
#line 132 "lex.flex"
{ss << L"double";}
            break;
          case 104: // rule at line 133: (?:خ)(?:ط)(?:أ)
#line 133 "lex.flex"
{ss << L"false";}
            break;
          case 105: // rule at line 134: (?:ا)(?:ذ)(?:ا)
          case 106: // rule at line 135: (?:إ)(?:ذ)(?:ا)
#line 135 "lex.flex"
{ss << L"if";}
            break;
          case 107: // rule at line 136: (?:ن)(?:ف)(?:ي)
#line 136 "lex.flex"
{ss << L"not";}
            break;
          case 108: // rule at line 137: (?:س)(?:ر)(?:ي)
#line 137 "lex.flex"
{ss << L"private";}
            break;
          case 109: // rule at line 138: (?:ا)(?:ع)(?:د)
          case 110: // rule at line 139: (?:أ)(?:ع)(?:د)
#line 139 "lex.flex"
{ss << L"return";}
            break;
          case 111: // rule at line 140: (?:ح)(?:ج)(?:م)
#line 140 "lex.flex"
{ss << L"sizeof";}
            break;
          case 112: // rule at line 141: (?:ه)(?:ذ)(?:ا)
          case 113: // rule at line 142: (?:ه)(?:ذ)(?:ه)
#line 142 "lex.flex"
{ss << L"this";}
            break;
          case 114: // rule at line 143: (?:ل)(?:م)(?:ا)
#line 143 "lex.flex"
{ss << L"while";}


            break;
          case 115: // rule at line 146: (?:أ)(?:و)
          case 116: // rule at line 147: (?:ا)(?:و)
#line 147 "lex.flex"
{ss << L"or";}
            break;
          case 117: // rule at line 148: (?:ض)(?:م)
#line 148 "lex.flex"
{ss << L"inline";}


            break;
          case 118: // rule at line 151: (?:و)
#line 151 "lex.flex"
{ss << L"and";}
            break;
          case 119: // rule at line 152: (?:ل)
#line 152 "lex.flex"
{ss << L"for";}

            break;
          case 120: // rule at line 154: (?:\x5b|\x5d|\x7b|\x7d)
#line 154 "lex.flex"
{ss << wstr();}

            break;
          case 121: // rule at line 156: (?:٠)
#line 156 "lex.flex"
{ss << L"0";}
            break;
          case 122: // rule at line 157: (?:١)
#line 157 "lex.flex"
{ss << L"1";}
            break;
          case 123: // rule at line 158: (?:٢)
#line 158 "lex.flex"
{ss << L"2";}
            break;
          case 124: // rule at line 159: (?:٣)
#line 159 "lex.flex"
{ss << L"3";}
            break;
          case 125: // rule at line 160: (?:٤)
#line 160 "lex.flex"
{ss << L"4";}
            break;
          case 126: // rule at line 161: (?:٥)
#line 161 "lex.flex"
{ss << L"5";}
            break;
          case 127: // rule at line 162: (?:٦)
#line 162 "lex.flex"
{ss << L"6";}
            break;
          case 128: // rule at line 163: (?:٧)
#line 163 "lex.flex"
{ss << L"7";}
            break;
          case 129: // rule at line 164: (?:٨)
#line 164 "lex.flex"
{ss << L"8";}
            break;
          case 130: // rule at line 165: (?:٩)
#line 165 "lex.flex"
{ss << L"9";}
            break;
          case 131: // rule at line 166: (?:؛)
#line 166 "lex.flex"
{ss << L";";}
            break;
          case 132: // rule at line 167: (?:،)
#line 167 "lex.flex"
{ss << L",";}

            break;
          case 133: // rule at line 169: (?:\Q.\E)+
          case 134: // rule at line 170: (?:\Q,\E)+
#line 170 "lex.flex"
{ss << wstr();}
            break;
          case 135: // rule at line 171: (?:_|[\xd8-\xdb][\x80-\xbf])+
#line 171 "lex.flex"
{ss << wstr();}
            break;
          case 136: // rule at line 172: (?:(?:[0-9]|[A-Z]|[a-z]))+
#line 172 "lex.flex"
{ss << wstr();}
            break;
          case 137: // rule at line 173: (?:[\x09-\x0d]|\x20|\x5b)
#line 173 "lex.flex"
{ss << wstr();}
            break;
          case 138: // rule at line 174: (?:[!-#]|[%-,]|[./]|[:-_]|\x7c|\x7e)
#line 174 "lex.flex"
{ss << wstr();}
            break;
          case 139: // rule at line 175: (?:.[\x80-\xbf]*)
#line 175 "lex.flex"
{ss << wstr();}

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 178 "lex.flex"

int main(int argc, char **argv)
{
  FILE *fd = stdin;
  if (argc > 1 && (fd = fopen(argv[1], "r")) == NULL)
    exit(EXIT_FAILURE);


  std::string fileName = argv[1];

  if(fileName.substr(fileName.find_last_of(".") + 1) != "spp") {
    std::cerr << "Invalid File Extention";
    exit(EXIT_FAILURE);
  }

  std::locale::global(std::locale(""));
  std::wofstream of;
  Lexer(fd).lex();
  std::wstring wstr = ss.str();

  std::size_t lastindex = fileName.find_last_of(".");
  std::string rawname = fileName.substr(0, lastindex);
  rawname += ".cpp";

  of.open(rawname ,std::ios::out|std::ios::trunc|std::ios::binary);
  of << wstr;
  of.close();
  return 0;
}

